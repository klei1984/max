/* Copyright (c) 2025 M.A.X. Port Team
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

#include "world.hpp"

#include <SDL3/SDL.h>

#include "color.h"
#include "drawloadbar.hpp"
#include "gfx.hpp"
#include "resource_manager.hpp"
#include "sha2.h"
#include "timer.h"
#include "window_manager.hpp"

World::World(ResourceID resource_id)
    : m_resource_id(resource_id),
      m_is_fully_loaded(false),
      m_tile_count(0),
      m_layer_count(0),
      m_minimap_window_scale(1.0),
      m_color_cycle_step(63) {
    m_map_size.x = 0;
    m_map_size.y = 0;
    m_minimap_window_size.x = 0;
    m_minimap_window_size.y = 0;
    m_minimap_window_offset.x = 0;
    m_minimap_window_offset.y = 0;

    char* resource_name = reinterpret_cast<char*>(ResourceManager_ReadResource(resource_id));

    if (!resource_name) {
        SDL_Log("World: Failed to resolve ResourceID %d to filename", resource_id);

        return;
    }

    auto filename = std::string(resource_name);

    delete[] resource_name;

    auto path_prefix = ResourceManager_FilePathGameData;

    m_file_path = (path_prefix / ResourceManager_StringToLowerCase(filename)).lexically_normal();

    std::error_code ec;

    if (!std::filesystem::exists(m_file_path, ec) || ec) {
        m_file_path = (path_prefix / ResourceManager_StringToUpperCase(filename)).lexically_normal();

        if (!std::filesystem::exists(m_file_path, ec) || ec) {
            SDL_Log("World: WRL file not found: %s", filename.c_str());

            return;
        }
    }

    FILE* fp = fopen(m_file_path.string().c_str(), "rb");

    if (!fp) {
        SDL_Log("World: Failed to open WRL file: %s", m_file_path.string().c_str());

        return;
    }

    if (!ParseWrlFilePreview(fp)) {
        SDL_Log("World: Failed to parse WRL preview: %s", m_file_path.string().c_str());
    }

    fclose(fp);
}

World::~World() {}

bool World::LoadFullMap(DrawLoadBar* load_bar) {
    if (!load_bar) {
        SDL_Log("World: LoadFullMap called with null load_bar");

        return false;
    }

    if (m_is_fully_loaded) {
        SDL_Log("World: LoadFullMap called but map already fully loaded");

        return true;
    }

    FILE* fp = fopen(m_file_path.string().c_str(), "rb");

    if (!fp) {
        SDL_Log("World: Failed to open WRL file for full load: %s", m_file_path.string().c_str());

        return false;
    }

    load_bar->SetValue(0);

    // Skip to position after preview data
    if (fseek(fp, 3, SEEK_SET) != 0) {
        fclose(fp);

        return false;
    }

    uint16_t map_layer_count = 0;

    if (1 != fread(&map_layer_count, sizeof(uint16_t), 1, fp)) {
        fclose(fp);

        return false;
    }

    Point map_layer_dimensions[12];

    if (map_layer_count != fread(&map_layer_dimensions, sizeof(Point), map_layer_count, fp)) {
        fclose(fp);

        return false;
    }

    const int32_t map_minimap_count = 1;
    const uint32_t map_cell_count = static_cast<uint32_t>(m_map_size.x * m_map_size.y);

    // Skip minimap data (already loaded in constructor)
    if (fseek(fp, (map_minimap_count - 1) * map_cell_count, SEEK_CUR) != 0) {
        fclose(fp);

        return false;
    }

    // Skip minimap itself
    if (fseek(fp, map_cell_count, SEEK_CUR) != 0) {
        fclose(fp);

        return false;
    }

    if (!LoadTilesAndMetadata(fp, load_bar)) {
        fclose(fp);

        return false;
    }

    fclose(fp);

    ApplyBugFixes();
    InitColorCycles();

    m_is_fully_loaded = true;

    load_bar->SetValue(100);

    return true;
}

void World::UnloadFullMap() {
    if (!m_is_fully_loaded) {
        return;
    }

    m_tile_ids.reset();
    m_tile_buffer.reset();
    m_surface_map.reset();
    m_cargo_map.reset();
    m_color_cycles.clear();

    m_is_fully_loaded = false;
}

bool World::IsFullyLoaded() const { return m_is_fully_loaded; }

void World::UpdateColorAnimations(uint64_t current_time) {
    if (!m_is_fully_loaded) {
        return;
    }

    for (auto& cycle : m_color_cycles) {
        if ((current_time - cycle.time_stamp) >= cycle.time_limit) {
            cycle.time_stamp = current_time;

            const int32_t start_index = cycle.start_index;
            const int32_t end_index = cycle.end_index;
            const int32_t step_count = end_index - start_index;

            Color* start_address = &WindowManager_ColorPalette[start_index * 3];

            if (step_count > 0) {
                if (cycle.rotate_direction == 1) {
                    Color* end_address = &WindowManager_ColorPalette[end_index * 3];
                    Color rgb_temp[3];

                    memcpy(rgb_temp, end_address, 3);
                    memmove(&start_address[3], start_address, 3 * step_count);
                    memcpy(start_address, rgb_temp, 3);

                } else {
                    Color* end_address = &WindowManager_ColorPalette[end_index * 3];
                    Color rgb_temp[3];

                    memcpy(rgb_temp, start_address, 3);
                    memmove(start_address, &start_address[3], 3 * step_count);
                    memcpy(end_address, rgb_temp, 3);
                }
            } else {
                if (m_color_cycle_step <= 7) {
                    m_color_cycle_step = 63;

                } else {
                    m_color_cycle_step /= 2;
                }

                start_address[1] = m_color_cycle_step;
            }

            for (int32_t i = start_index; i <= end_index; ++i) {
                Color_SetSystemPaletteEntry(i, WindowManager_ColorPalette[i * 3 + 0],
                                            WindowManager_ColorPalette[i * 3 + 1],
                                            WindowManager_ColorPalette[i * 3 + 2]);
            }
        }
    }
}

bool World::ParseWrlFilePreview(FILE* fp) {
    if (fseek(fp, 3, SEEK_SET) != 0) {
        return false;
    }

    uint16_t map_layer_count = 0;

    if (1 != fread(&map_layer_count, sizeof(uint16_t), 1, fp)) {
        return false;
    }

    m_layer_count = map_layer_count;

    Point map_layer_dimensions[12];

    if (map_layer_count != fread(&map_layer_dimensions, sizeof(Point), map_layer_count, fp)) {
        return false;
    }

    const int32_t map_minimap_count = 1;

    m_map_size = map_layer_dimensions[map_minimap_count - 1];

    const uint32_t map_cell_count = static_cast<uint32_t>(m_map_size.x * m_map_size.y);

    // Skip to minimap data
    if (fseek(fp, (map_minimap_count - 1) * map_cell_count, SEEK_CUR) != 0) {
        return false;
    }

    m_minimap_fov = std::make_unique<uint8_t[]>(map_cell_count);
    m_minimap = std::make_unique<uint8_t[]>(map_cell_count);

    if (!m_minimap_fov || !m_minimap) {
        return false;
    }

    if (map_cell_count != fread(m_minimap_fov.get(), sizeof(uint8_t), map_cell_count, fp)) {
        return false;
    }

    memcpy(m_minimap.get(), m_minimap_fov.get(), map_cell_count);

    CalculateMinimapScaling();

    return true;
}

bool World::LoadTilesAndMetadata(FILE* fp, DrawLoadBar* load_bar) {
    const uint32_t map_cell_count = static_cast<uint32_t>(m_map_size.x * m_map_size.y);
    int32_t file_position = ftell(fp);

    if (file_position == -1) {
        return false;
    }

    // Skip to tile ID map
    if (fseek(fp, sizeof(uint16_t) * map_cell_count, SEEK_CUR) != 0) {
        return false;
    }

    if (1 != fread(&m_tile_count, sizeof(uint16_t), 1, fp)) {
        return false;
    }

    uint8_t* palette = new (std::nothrow) uint8_t[PALETTE_STRIDE * PALETTE_SIZE];

    if (!palette) {
        return false;
    }

    if (fseek(fp, GFX_MAP_TILE_SIZE * GFX_MAP_TILE_SIZE * m_tile_count, SEEK_CUR) != 0) {
        delete[] palette;

        return false;
    }

    if (PALETTE_STRIDE * PALETTE_SIZE != fread(palette, sizeof(uint8_t), PALETTE_STRIDE * PALETTE_SIZE, fp)) {
        delete[] palette;

        return false;
    }

    m_palette = std::make_unique<uint8_t[]>(PALETTE_STRIDE * PALETTE_SIZE);

    memcpy(m_palette.get(), palette, PALETTE_STRIDE * PALETTE_SIZE);

    for (int32_t i = 64 * PALETTE_STRIDE; i < 160 * PALETTE_STRIDE; ++i) {
        WindowManager_ColorPalette[i] = palette[i] / 4;
    }

    Color_SetSystemPalette(WindowManager_ColorPalette);
    Color_SetColorPalette(WindowManager_ColorPalette);

    delete[] palette;

    if (fseek(fp, file_position, SEEK_SET) != 0) {
        return false;
    }

    m_tile_ids = std::make_unique<uint16_t[]>(map_cell_count);

    if (!m_tile_ids) {
        return false;
    }

    {
        uint32_t data_chunk_size = map_cell_count / 4;

        for (uint32_t data_offset = 0; data_offset < map_cell_count;) {
            data_chunk_size = std::min(data_chunk_size, map_cell_count - data_offset);

            if (fread(&m_tile_ids[data_offset], sizeof(uint16_t), data_chunk_size, fp) != data_chunk_size) {
                return false;
            }

            data_offset += data_chunk_size;

            load_bar->SetValue(20 * data_offset / map_cell_count);
        }
    }

    // Skip tile count (already read)
    if (fseek(fp, sizeof(uint16_t), SEEK_CUR) != 0) {
        return false;
    }

    if (!LoadMapTiles(fp, load_bar)) {
        return false;
    }

    // Skip palette (already loaded)
    if (fseek(fp, PALETTE_STRIDE * PALETTE_SIZE, SEEK_CUR) != 0) {
        return false;
    }

    load_bar->SetValue(73);

    // Load pass table and build surface map
    {
        const uint8_t PassData[] = {SURFACE_TYPE_LAND, SURFACE_TYPE_WATER, SURFACE_TYPE_COAST, SURFACE_TYPE_AIR};
        uint8_t* pass_table = new (std::nothrow) uint8_t[m_tile_count];

        if (!pass_table) {
            return false;
        }

        m_surface_map = std::make_unique<uint8_t[]>(map_cell_count);

        if (!m_surface_map) {
            delete[] pass_table;

            return false;
        }

        if (m_tile_count != fread(pass_table, sizeof(uint8_t), m_tile_count, fp)) {
            delete[] pass_table;

            return false;
        }

        for (int32_t i = 0; i < m_tile_count; ++i) {
            pass_table[i] = PassData[pass_table[i]];
        }

        for (uint32_t i = 0; i < map_cell_count; ++i) {
            m_surface_map[i] = pass_table[m_tile_ids[i]];
        }

        delete[] pass_table;
    }

    load_bar->SetValue(76);

    m_cargo_map = std::make_unique<uint16_t[]>(map_cell_count);

    if (!m_cargo_map) {
        return false;
    }

    for (uint32_t i = 0; i < map_cell_count; ++i) {
        m_cargo_map[i] = 0;
    }

    ApplyPaletteAndTints(load_bar);

    return true;
}

bool World::LoadMapTiles(FILE* fp, DrawLoadBar* load_bar) {
    int32_t tile_size{GFX_MAP_TILE_SIZE};
    int32_t tile_count_stride{(m_tile_count + 7) / 8};
    uint8_t* tile_data_chunk{nullptr};

    if (ResourceManager_DisableEnhancedGraphics) {
        tile_size /= 2;
        tile_data_chunk = new (std::nothrow) uint8_t[tile_count_stride * GFX_MAP_TILE_SIZE * GFX_MAP_TILE_SIZE];
    }

    m_tile_buffer = std::make_unique<uint8_t[]>(m_tile_count * tile_size * tile_size);
    if (!m_tile_buffer) {
        delete[] tile_data_chunk;

        return false;
    }

    for (int32_t i = 0; i < m_tile_count; i += tile_count_stride) {
        load_bar->SetValue(i * 50 / m_tile_count + 20);

        if (!ResourceManager_DisableEnhancedGraphics) {
            tile_data_chunk = &m_tile_buffer[i * GFX_MAP_TILE_SIZE * GFX_MAP_TILE_SIZE];
        }

        const int32_t tile_count = std::min(tile_count_stride, m_tile_count - i);
        const uint32_t data_size = tile_count * GFX_MAP_TILE_SIZE * GFX_MAP_TILE_SIZE;

        if (data_size != fread(tile_data_chunk, sizeof(uint8_t), data_size, fp)) {
            if (ResourceManager_DisableEnhancedGraphics) {
                delete[] tile_data_chunk;
            }

            return false;
        }

        if (ResourceManager_DisableEnhancedGraphics) {
            uint8_t* source_address{tile_data_chunk};
            uint8_t* destination_address{&m_tile_buffer[tile_size * tile_size * i]};

            for (int32_t j = 0; j < tile_count; ++j) {
                for (int32_t k = 0; k < tile_size; ++k) {
                    for (int32_t l = 0; l < tile_size; ++l) {
                        *destination_address = *source_address;
                        destination_address += 1;
                        source_address += 2;
                    }

                    source_address += 64;
                }
            }
        }
    }

    load_bar->SetValue(70);

    if (ResourceManager_DisableEnhancedGraphics) {
        delete[] tile_data_chunk;
    }

    return true;
}

void World::ApplyPaletteAndTints(DrawLoadBar* load_bar) {
    int32_t progress_bar_value = 76;

    for (int32_t i = 0, j = 0; i < PALETTE_STRIDE * PALETTE_SIZE; i += PALETTE_STRIDE, ++j) {
        int32_t r = WindowManager_ColorPalette[i];
        int32_t g = WindowManager_ColorPalette[i + 1];
        int32_t b = WindowManager_ColorPalette[i + 2];

        const int32_t factor = 7;

        r = (std::max(factor, r) * 31) / 63;
        g = (std::max(factor, g) * 31) / 63;
        b = (std::max(factor, b) * 31) / 63;

        ResourceManager_DarkeningColorIndexTable[j] = Color_MapColor(WindowManager_ColorPalette, r, g, b, false);
    }

    progress_bar_value += 3;
    load_bar->SetValue(progress_bar_value);

    // Generate brightness color index table (7 levels)
    for (int32_t i = 0, l = 0; i < 7 * 32; i += 32, ++l) {
        for (int32_t j = 0, k = 0; j < PALETTE_STRIDE * PALETTE_SIZE; j += PALETTE_STRIDE, ++k) {
            if (j == PALETTE_STRIDE * 31) {
                ResourceManager_BrightnessColorIndexTable[l * PALETTE_SIZE + k] = 31;
            } else {
                int32_t r = (WindowManager_ColorPalette[j] * i) / (7 * 32);
                int32_t g = (WindowManager_ColorPalette[j + 1] * i) / (7 * 32);
                int32_t b = (WindowManager_ColorPalette[j + 2] * i) / (7 * 32);

                ResourceManager_BrightnessColorIndexTable[l * PALETTE_SIZE + k] =
                    Color_MapColor(WindowManager_ColorPalette, r, g, b, false);
            }
        }

        progress_bar_value += 3;
        load_bar->SetValue(progress_bar_value);
    }

    InitGridOverlayColors();
}

void World::InitGridOverlayColors() {
    m_grid_overlay_color_land = Color_MapColor(WindowManager_ColorPalette, 49 / 4, 97 / 4, 8 / 4, false);
    m_grid_overlay_color_water = Color_MapColor(WindowManager_ColorPalette, 58 / 4, 81 / 4, 173 / 4, false);
    m_grid_overlay_color_coast = Color_MapColor(WindowManager_ColorPalette, 82 / 4, 158 / 4, 206 / 4, false);
    m_grid_overlay_color_air = Color_MapColor(WindowManager_ColorPalette, 206 / 4, 32 / 4, 0 / 4, false);
}

void World::InitColorCycles() {
    m_color_cycles.clear();
    m_color_cycles.reserve(13);

    m_color_cycles.push_back({9, 12, 0, TIMER_FPS_TO_MS(9), 0});
    m_color_cycles.push_back({13, 16, 1, TIMER_FPS_TO_MS(6), 0});
    m_color_cycles.push_back({17, 20, 1, TIMER_FPS_TO_MS(9), 0});
    m_color_cycles.push_back({21, 24, 1, TIMER_FPS_TO_MS(6), 0});
    m_color_cycles.push_back({25, 30, 1, TIMER_FPS_TO_MS(2), 0});
    m_color_cycles.push_back({31, 31, 1, TIMER_FPS_TO_MS(6), 0});
    m_color_cycles.push_back({96, 102, 1, TIMER_FPS_TO_MS(8), 0});
    m_color_cycles.push_back({103, 109, 1, TIMER_FPS_TO_MS(8), 0});
    m_color_cycles.push_back({110, 116, 1, TIMER_FPS_TO_MS(10), 0});
    m_color_cycles.push_back({117, 122, 1, TIMER_FPS_TO_MS(6), 0});
    m_color_cycles.push_back({123, 127, 1, TIMER_FPS_TO_MS(6), 0});
}

void World::ApplyBugFixes() {
    switch (m_resource_id) {
        case GREEN_4: {
            // Fix tile 190 pass table info (should be LAND, not WATER)
            const std::string reference{"dbcfc4495334640776e6a0b1776651f904583aa87f193a43436e6b1f04635241"};
            auto hash = ComputeHash();

            if (reference == hash) {
                constexpr uint16_t tile_190{190u};
                const uint32_t map_cell_count{static_cast<uint32_t>(m_map_size.x * m_map_size.y)};

                for (uint32_t i = 0; i < map_cell_count; ++i) {
                    if (m_tile_ids[i] == tile_190) {
                        m_surface_map[i] = SURFACE_TYPE_LAND;
                    }
                }

                SDL_Log("World: Applied GREEN_4 bug fix (tile 190 pass table correction)");
            }
        } break;

        case SNOW_3: {
            // Fix tile at grid cell position (57,57) in tile ID map
            const std::string reference{"a625d409ca1d5cd24cdeed165813e5b79c538b123491791016372492f5106801"};
            auto hash = ComputeHash();

            if (reference == hash) {
                constexpr uint16_t tile_55{55u};
                constexpr uint16_t grid_x_57{56u};  // 0-indexed, so 57 -> 56
                constexpr uint16_t grid_y_57{56u};

                m_tile_ids[m_map_size.x * grid_y_57 + grid_x_57] = tile_55;

                SDL_Log("World: Applied SNOW_3 bug fix (grid 57,57 tile correction)");
            }
        } break;

        case SNOW_5: {
            // Fix missing tile art by injecting tile 411 data
            const std::string reference{"11a9255e65af53b6438803d0aef4ca96ed9d57575da3cf13779838ccda25a6e9"};
            auto hash = ComputeHash();

            if (reference == hash) {
                constexpr uint16_t tile_411{411u};
                constexpr uint16_t grid_x_55{54u};
                constexpr uint16_t grid_y_66{65u};

                // Tile 411 pixel data (64x64, but will be downsampled if needed)
                const uint8_t tile_data[4096] = {
                    0x42, 0x49, 0x4E, 0x4E, 0x40, 0x53, 0x40, 0x42, 0x59, 0x57, 0x57, 0x59, 0x57, 0x54, 0x54, 0x53,
                    0x59, 0x52, 0x52, 0x54, 0x49, 0x53, 0x53, 0x54, 0x4E, 0x57, 0x52, 0x57, 0x4F, 0x59, 0x4F, 0x59,
                    0x4F, 0x59, 0x4F, 0x40, 0x40, 0x4E, 0x49, 0x52, 0x42, 0x49, 0x4F, 0x59, 0x53, 0x44, 0x42, 0x54,
                    0x42, 0x53, 0x4F, 0x52, 0x4E, 0x40, 0x53, 0x59, 0x4E, 0x52, 0x5A, 0x57, 0x4E, 0x5A, 0x42, 0x4A,
                    0x4A, 0x4E, 0x42, 0x4E, 0x42, 0x49, 0x4A, 0x4E, 0x57, 0x59, 0x59, 0x49, 0x52, 0x53, 0x42, 0x49,
                    0x4F, 0x40, 0x4F, 0x4F, 0x4F, 0x53, 0x53, 0x42, 0x49, 0x59, 0x52, 0x53, 0x49, 0x53, 0x42, 0x54,
                    0x42, 0x59, 0x4A, 0x52, 0x59, 0x53, 0x52, 0x4E, 0x59, 0x49, 0x44, 0x40, 0x42, 0x52, 0x49, 0x4E,
                    0x4F, 0x53, 0x4F, 0x49, 0x53, 0x59, 0x53, 0x44, 0x42, 0x4E, 0x59, 0x59, 0x54, 0x52, 0x49, 0x57,
                    0x42, 0x4E, 0x4F, 0x52, 0x4F, 0x4F, 0x53, 0x4E, 0x53, 0x4E, 0x5A, 0x52, 0x42, 0x4F, 0x5A, 0x4E,
                    0x53, 0x53, 0x44, 0x49, 0x42, 0x44, 0x53, 0x49, 0x44, 0x57, 0x49, 0x49, 0x59, 0x52, 0x96, 0x9D,
                    0x9B, 0xB5, 0x42, 0x4E, 0x4F, 0x4E, 0xC4, 0xE7, 0x9B, 0x9B, 0xC7, 0xBF, 0x42, 0x4A, 0x52, 0x4F,
                    0x57, 0x4E, 0x4A, 0x4E, 0x40, 0x4E, 0x42, 0x44, 0x4F, 0x40, 0x4A, 0x44, 0x42, 0x42, 0x40, 0x52,
                    0x59, 0x42, 0x53, 0x53, 0x49, 0x40, 0x4F, 0x42, 0x4F, 0x5A, 0x59, 0x4F, 0x4F, 0x4E, 0x4F, 0x49,
                    0x52, 0x59, 0x44, 0x4E, 0x57, 0x54, 0x59, 0x42, 0x4E, 0x44, 0x40, 0x42, 0x57, 0x4F, 0x87, 0x97,
                    0xFB, 0xB2, 0x40, 0x49, 0x59, 0xC5, 0x9B, 0x9B, 0x9B, 0xC7, 0x90, 0x81, 0x4A, 0x52, 0x52, 0x52,
                    0x57, 0x59, 0x54, 0x54, 0x53, 0x59, 0x42, 0x49, 0x59, 0x4A, 0x53, 0x4E, 0x40, 0x40, 0x52, 0x4F,
                    0x49, 0x44, 0x42, 0x40, 0x49, 0x4E, 0x49, 0x49, 0x59, 0x5A, 0x57, 0x52, 0x57, 0x54, 0x53, 0x52,
                    0x53, 0x4F, 0x49, 0x44, 0x59, 0x57, 0x4E, 0x4E, 0x42, 0x40, 0x53, 0x59, 0x52, 0x59, 0xC5, 0x9B,
                    0x9B, 0xC1, 0x44, 0x83, 0x9B, 0x9B, 0x9B, 0x9B, 0x94, 0x90, 0x81, 0x49, 0x4F, 0x4F, 0x4F, 0x52,
                    0x4F, 0x49, 0x49, 0x4E, 0x42, 0x49, 0x49, 0x40, 0x54, 0x53, 0x52, 0x59, 0x44, 0x59, 0x49, 0x49,
                    0x42, 0x40, 0x54, 0x42, 0x42, 0x42, 0x49, 0x4F, 0x4A, 0x52, 0x49, 0x42, 0x4F, 0x53, 0x59, 0x42,
                    0x4E, 0x57, 0x49, 0x53, 0x4F, 0x59, 0x59, 0x4F, 0x4E, 0x40, 0x44, 0x42, 0x49, 0x42, 0x96, 0x9E,
                    0x9D, 0x9B, 0xDC, 0x9B, 0x9B, 0x9B, 0x9B, 0xC4, 0x90, 0x4E, 0x42, 0x49, 0x4F, 0x4F, 0x4F, 0x4F,
                    0x4F, 0x49, 0x40, 0x40, 0x40, 0x4E, 0x57, 0x4F, 0x44, 0x4F, 0x42, 0x42, 0x53, 0x42, 0x40, 0x52,
                    0x4F, 0x4E, 0x52, 0x4A, 0x54, 0x44, 0x52, 0x57, 0x42, 0x49, 0x52, 0x4E, 0x57, 0x57, 0x52, 0x49,
                    0x49, 0x44, 0x42, 0x4E, 0x4F, 0x4F, 0x42, 0x59, 0x52, 0x42, 0x49, 0x40, 0x57, 0x59, 0x49, 0x8E,
                    0x9D, 0x9B, 0x9B, 0x9B, 0x9B, 0x9B, 0xC7, 0x9B, 0x53, 0x42, 0x42, 0x49, 0x4F, 0x4F, 0x4E, 0x4F,
                    0x4F, 0x42, 0x40, 0x4F, 0x42, 0x42, 0x53, 0x4A, 0x59, 0x53, 0x40, 0x49, 0x52, 0x4F, 0x4E, 0x4E,
                    0x4E, 0x4F, 0x54, 0x59, 0x4E, 0x4F, 0x53, 0x4E, 0x4E, 0x42, 0x4E, 0x44, 0x4F, 0x59, 0x52, 0x4E,
                    0x40, 0x49, 0x52, 0x49, 0x49, 0x42, 0x49, 0x52, 0x4F, 0x42, 0x4F, 0x52, 0x44, 0x4E, 0x53, 0x4A,
                    0xD3, 0x9D, 0x9E, 0x9E, 0x9E, 0x9E, 0x9F, 0xD7, 0x87, 0x84, 0xB3, 0x8C, 0xD3, 0x96, 0xB4, 0x52,
                    0x4F, 0x52, 0x4A, 0x49, 0x4E, 0x44, 0x53, 0x42, 0x4E, 0x57, 0x49, 0x49, 0x40, 0x53, 0x49, 0x42,
                    0x4E, 0x59, 0x57, 0x4F, 0x57, 0x49, 0x53, 0x53, 0x4E, 0x4F, 0x44, 0x49, 0x42, 0x49, 0x4F, 0x53,
                    0x54, 0x4A, 0x49, 0x53, 0x4E, 0x52, 0x53, 0x4F, 0x53, 0x49, 0x52, 0x53, 0x4A, 0x4F, 0x54, 0x4F,
                    0x88, 0x9D, 0x9E, 0x9D, 0x9D, 0x9D, 0x9A, 0xCB, 0xCE, 0x9E, 0x9B, 0xE8, 0xCE, 0xE8, 0xE8, 0x95,
                    0x57, 0x42, 0x49, 0x52, 0x4E, 0x42, 0x4E, 0x40, 0x42, 0x52, 0x52, 0x52, 0x4E, 0x4E, 0x40, 0x42,
                    0x53, 0x42, 0x4F, 0x4E, 0x49, 0x40, 0x42, 0x52, 0x49, 0x54, 0x57, 0x53, 0x42, 0x42, 0x4E, 0x54,
                    0x57, 0x59, 0x57, 0x4A, 0x53, 0x5A, 0x4E, 0x53, 0x53, 0x4F, 0x57, 0x4A, 0x40, 0x42, 0x49, 0x57,
                    0x59, 0xC7, 0x9B, 0x9B, 0x9B, 0x9D, 0xCE, 0xCE, 0xE8, 0xE8, 0x9D, 0xCE, 0x98, 0x87, 0xD1, 0x9E,
                    0xCA, 0x54, 0x53, 0x59, 0x53, 0x49, 0x4A, 0x59, 0x59, 0x59, 0x54, 0x54, 0x53, 0x4E, 0x4F, 0x52,
                    0x53, 0x53, 0x54, 0x49, 0x49, 0x49, 0x42, 0x54, 0x4F, 0x53, 0x4F, 0x59, 0x4F, 0x53, 0x59, 0x52,
                    0x53, 0x4E, 0x4A, 0x49, 0x52, 0x57, 0x53, 0x57, 0x57, 0x4A, 0x4F, 0x40, 0x42, 0x52, 0x4F, 0x44,
                    0x53, 0x9D, 0x9D, 0x9E, 0x9F, 0x9F, 0x9F, 0x9F, 0x9F, 0x9F, 0x9F, 0x9F, 0xCE, 0xDB, 0x9B, 0xD2,
                    0xD3, 0x53, 0x49, 0x54, 0x54, 0x4F, 0x4F, 0x57, 0x59, 0x59, 0x4E, 0x49, 0x49, 0x40, 0x4E, 0x4F,
                    0x42, 0x4F, 0x53, 0x4E, 0x49, 0x53, 0x53, 0x4F, 0x4F, 0x4E, 0x4F, 0x52, 0x49, 0x53, 0x54, 0x59,
                    0x52, 0x42, 0x42, 0x49, 0x49, 0x4F, 0x4E, 0x54, 0x49, 0x4E, 0x49, 0x4F, 0x4E, 0x54, 0x44, 0x40,
                    0x4E, 0x52, 0x9F, 0x9F, 0xCF, 0x9F, 0x9F, 0x9F, 0x9F, 0x9F, 0x9F, 0x9F, 0x9F, 0x9F, 0x9F, 0xE8,
                    0x9E, 0x4F, 0x44, 0x42, 0x4F, 0x4E, 0x53, 0x4F, 0x4F, 0x4F, 0x4F, 0x52, 0x59, 0x53, 0x4F, 0x53,
                    0x42, 0x49, 0x4E, 0x49, 0x54, 0x40, 0x42, 0x4E, 0x49, 0x57, 0x5F, 0x4E, 0x57, 0x40, 0x40, 0x4E,
                    0x4F, 0x4F, 0x59, 0x49, 0x4E, 0x59, 0x53, 0x53, 0x4F, 0x4E, 0x52, 0x49, 0x4E, 0x49, 0x44, 0x42,
                    0x49, 0x54, 0x85, 0xDE, 0x9F, 0x9F, 0x9F, 0xD2, 0x96, 0xD2, 0xE8, 0xCE, 0x9F, 0x9F, 0x9F, 0x9F,
                    0x9F, 0x4F, 0x49, 0x4E, 0x57, 0x53, 0x4A, 0x59, 0x52, 0x54, 0x4F, 0x4F, 0x40, 0x52, 0x53, 0x44,
                    0x42, 0x4A, 0x53, 0x49, 0x49, 0x49, 0x42, 0x54, 0x42, 0x4E, 0x53, 0x4F, 0x49, 0x49, 0x52, 0x54,
                    0x42, 0x42, 0x4F, 0x42, 0x4F, 0x4E, 0x42, 0x4E, 0x59, 0x52, 0x53, 0x53, 0x52, 0x42, 0x59, 0x54,
                    0x42, 0x42, 0x4F, 0x40, 0xD4, 0x9E, 0x9E, 0xD3, 0x92, 0x92, 0x96, 0x92, 0xD2, 0x9F, 0x9F, 0x9F,
                    0x9F, 0x49, 0x54, 0x52, 0x4F, 0x54, 0x5A, 0x49, 0x57, 0x54, 0x5A, 0x49, 0x40, 0x49, 0x57, 0x42,
                    0x4F, 0x53, 0x53, 0x53, 0x42, 0x53, 0x42, 0x57, 0x4F, 0x49, 0x4A, 0x4F, 0x4E, 0x49, 0x4E, 0x4F,
                    0x40, 0x54, 0x4A, 0x40, 0x4E, 0x40, 0x4E, 0x59, 0x4A, 0x54, 0x4E, 0x53, 0x53, 0x49, 0x59, 0x49,
                    0x49, 0x49, 0x4E, 0x40, 0x4E, 0x9B, 0x9D, 0xD4, 0x92, 0x92, 0x92, 0x92, 0xCA, 0x9E, 0x9F, 0x9F,
                    0x9F, 0x5A, 0x52, 0x57, 0x52, 0x49, 0x53, 0x4E, 0x53, 0x57, 0x54, 0x57, 0x49, 0x52, 0x4E, 0x49,
                    0x44, 0x4E, 0x52, 0x49, 0x59, 0x4F, 0x53, 0x4F, 0x4F, 0x54, 0x40, 0x4A, 0x40, 0x4A, 0x49, 0x4F,
                    0x4F, 0x4F, 0x4F, 0x40, 0x42, 0x40, 0x40, 0x54, 0x53, 0x4A, 0x42, 0x4E, 0x49, 0x53, 0x5A, 0x53,
                    0x42, 0x4E, 0x42, 0x40, 0x4E, 0x8E, 0x9D, 0x9D, 0xD4, 0x96, 0x92, 0x92, 0x92, 0x98, 0x9F, 0x9F,
                    0x9F, 0x40, 0x4E, 0x54, 0x54, 0x53, 0x42, 0x4F, 0x4A, 0x54, 0x40, 0x4F, 0x4E, 0x40, 0x4A, 0x4E,
                    0x42, 0x57, 0x49, 0x52, 0x5A, 0x49, 0x4F, 0x42, 0x49, 0x4E, 0x4E, 0x4E, 0x49, 0x49, 0x52, 0x49,
                    0x44, 0x42, 0x53, 0x4E, 0x49, 0x42, 0x4A, 0x53, 0x49, 0x4F, 0x4E, 0x53, 0x49, 0x49, 0x49, 0x49,
                    0x40, 0x59, 0x59, 0x52, 0x53, 0x82, 0xCA, 0x9D, 0x9D, 0xC6, 0x96, 0x92, 0x92, 0x92, 0xD3, 0xE8,
                    0x9E, 0x4F, 0x53, 0x54, 0x53, 0x49, 0x4F, 0x4E, 0x57, 0x5A, 0x53, 0x4A, 0x57, 0x42, 0x57, 0x49,
                    0x42, 0x49, 0x49, 0x4E, 0x49, 0x49, 0x4E, 0x42, 0x4F, 0x4E, 0x49, 0x40, 0x4E, 0x59, 0x53, 0x4F,
                    0x42, 0x57, 0x53, 0x52, 0x42, 0x49, 0x4A, 0x4E, 0x57, 0x52, 0x4F, 0x4E, 0x4F, 0x59, 0x52, 0x4E,
                    0x49, 0x53, 0x40, 0x4F, 0x59, 0x59, 0x9B, 0x9E, 0x9D, 0xC8, 0x92, 0x92, 0x92, 0x92, 0xCE, 0x9F,
                    0x9F, 0x54, 0x57, 0x54, 0x52, 0x53, 0x4F, 0x4E, 0x52, 0x40, 0x4E, 0x52, 0x53, 0x42, 0x49, 0x40,
                    0x42, 0x4E, 0x49, 0x52, 0x4E, 0x53, 0x42, 0x42, 0x59, 0x49, 0x54, 0x53, 0x42, 0x54, 0x59, 0x49,
                    0x49, 0x49, 0x49, 0x40, 0x52, 0x4F, 0x49, 0x42, 0x4E, 0x54, 0x54, 0x52, 0x53, 0x54, 0x57, 0x4A,
                    0x59, 0x4E, 0x59, 0x4F, 0x4A, 0x98, 0x9D, 0x9D, 0xC6, 0x92, 0x92, 0x92, 0xCA, 0x9F, 0x9F, 0x9F,
                    0x54, 0x53, 0x54, 0x57, 0x4E, 0x59, 0x59, 0x4E, 0x53, 0x40, 0x52, 0x52, 0x4F, 0x49, 0x42, 0x54,
                    0x53, 0x42, 0x52, 0x4F, 0x54, 0x49, 0x49, 0x4A, 0x4E, 0x4E, 0x53, 0x4F, 0x42, 0x54, 0x57, 0x52,
                    0x59, 0x4A, 0x40, 0x40, 0x4E, 0x4F, 0x49, 0x42, 0x52, 0x49, 0x4F, 0x4A, 0x4A, 0x52, 0x4E, 0x52,
                    0x42, 0x40, 0x54, 0x4A, 0x96, 0x9D, 0x9D, 0xD4, 0xD2, 0x96, 0xB4, 0xCE, 0x9F, 0x9F, 0x9F, 0x49,
                    0x44, 0x42, 0x52, 0x59, 0x4A, 0x57, 0x59, 0x4A, 0x59, 0x4A, 0x53, 0x53, 0x57, 0x49, 0x59, 0x42,
                    0x42, 0x53, 0x42, 0x49, 0x4F, 0x4A, 0x53, 0x42, 0x49, 0x49, 0x42, 0x52, 0x53, 0x59, 0x49, 0x4E,
                    0x52, 0x4F, 0x40, 0x4E, 0x54, 0x59, 0x53, 0x49, 0x4F, 0x4A, 0x4F, 0x4E, 0x59, 0x49, 0x49, 0x40,
                    0x53, 0x53, 0x52, 0x81, 0xCA, 0x9D, 0x9E, 0xD4, 0xD2, 0x92, 0x95, 0xD2, 0xD2, 0x9E, 0xCA, 0x4E,
                    0x4E, 0x49, 0x4E, 0x4E, 0x52, 0x40, 0x49, 0x4E, 0x54, 0x4E, 0x42, 0x57, 0x4E, 0x42, 0x54, 0x4E,
                    0x4E, 0x59, 0x4F, 0x4A, 0x4E, 0x4F, 0x4E, 0x49, 0x59, 0x59, 0x59, 0x4A, 0x53, 0x54, 0x53, 0x4A,
                    0x49, 0x53, 0x59, 0x52, 0x54, 0x4F, 0x49, 0x53, 0x4F, 0x49, 0x40, 0x57, 0x52, 0x52, 0x4E, 0x4F,
                    0x54, 0x52, 0x4F, 0x98, 0xCA, 0x9D, 0x9D, 0xD4, 0x92, 0xB4, 0xCA, 0xD4, 0xD3, 0xD2, 0x96, 0x4E,
                    0x4A, 0x44, 0x42, 0x4E, 0x4E, 0x59, 0x4E, 0x4E, 0x42, 0x49, 0x4E, 0x52, 0x4E, 0x4E, 0x54, 0x4F,
                    0x40, 0x4A, 0x54, 0x40, 0x4E, 0x42, 0x52, 0x53, 0x53, 0x4E, 0x4E, 0x4E, 0x59, 0x53, 0x53, 0x4E,
                    0x59, 0x54, 0x5A, 0x4E, 0x49, 0x42, 0x49, 0x4E, 0x4F, 0x59, 0x4F, 0x40, 0x49, 0x42, 0x59, 0x49,
                    0x59, 0x4E, 0x52, 0x92, 0xCA, 0x9D, 0x9D, 0xCA, 0xD3, 0xCA, 0xCA, 0xD2, 0xD3, 0xD3, 0xB4, 0x59,
                    0x4E, 0x4E, 0x49, 0x54, 0x59, 0x4E, 0x4F, 0x4F, 0x52, 0x52, 0x42, 0x4F, 0x49, 0x40, 0x52, 0x52,
                    0x42, 0x44, 0x4E, 0x49, 0x40, 0x44, 0x54, 0x53, 0x4E, 0x40, 0x59, 0x4E, 0x49, 0x49, 0x42, 0x42,
                    0x53, 0x4E, 0x49, 0x42, 0x40, 0x49, 0x44, 0x59, 0x52, 0x52, 0x4E, 0x52, 0x4E, 0x4E, 0x59, 0x54,
                    0x4F, 0x53, 0x4A, 0x96, 0xCA, 0x9D, 0x9D, 0x9D, 0xD4, 0xD4, 0xD3, 0xCA, 0xCA, 0xCA, 0x96, 0x49,
                    0x53, 0x53, 0x52, 0x52, 0x4F, 0x49, 0x42, 0x4E, 0x4F, 0x42, 0x44, 0x4F, 0x4F, 0x49, 0x4E, 0x53,
                    0x59, 0x4A, 0x54, 0x4A, 0x54, 0x40, 0x49, 0x4E, 0x40, 0x40, 0x49, 0x42, 0x49, 0x42, 0x49, 0x40,
                    0x4F, 0x4E, 0x54, 0x4E, 0x4F, 0x53, 0x42, 0x40, 0x54, 0x52, 0x49, 0x4E, 0x4E, 0x57, 0x49, 0x49,
                    0x59, 0x54, 0x49, 0x57, 0xCA, 0x9D, 0x9D, 0x9D, 0x9D, 0x9D, 0x9D, 0xD4, 0xD4, 0xD4, 0xD4, 0x54,
                    0x42, 0x52, 0x4E, 0x54, 0x54, 0x4A, 0x49, 0x40, 0x4F, 0x42, 0x49, 0x4A, 0x4F, 0x4F, 0x54, 0x4F,
                    0x52, 0x52, 0x57, 0x40, 0x4E, 0x49, 0x59, 0x42, 0x4E, 0x53, 0x40, 0x49, 0x49, 0x53, 0x42, 0x59,
                    0x42, 0x52, 0x53, 0x4E, 0x57, 0x57, 0x52, 0x53, 0x52, 0x4E, 0x42, 0x4E, 0x4A, 0x49, 0x44, 0x52,
                    0x57, 0x54, 0x53, 0x4E, 0x8E, 0x9D, 0x9D, 0x9D, 0x9D, 0x9D, 0x9D, 0x9D, 0x9D, 0xD4, 0xD2, 0x44,
                    0x52, 0x49, 0x49, 0x54, 0x52, 0x4E, 0x59, 0x49, 0x49, 0x4F, 0x4E, 0x49, 0x42, 0x4E, 0x59, 0x40,
                    0x49, 0x49, 0x40, 0x40, 0x59, 0x4F, 0x54, 0x59, 0x49, 0x54, 0x40, 0x4F, 0x4E, 0x52, 0x4F, 0x49,
                    0x49, 0x4F, 0x54, 0x54, 0x59, 0x4F, 0x4F, 0x59, 0x49, 0x52, 0x4E, 0x52, 0x57, 0x42, 0x4E, 0x4E,
                    0x4E, 0x54, 0x52, 0x53, 0x88, 0x9D, 0x9D, 0x9D, 0x9D, 0x9D, 0x9D, 0x9D, 0x9D, 0x9D, 0x96, 0x52,
                    0x53, 0x42, 0x52, 0x54, 0x54, 0x4E, 0x52, 0x53, 0x40, 0x59, 0x59, 0x59, 0x49, 0x53, 0x49, 0x4E,
                    0x53, 0x4E, 0x59, 0x40, 0x4F, 0x59, 0x49, 0x59, 0x53, 0x4E, 0x52, 0x57, 0x54, 0x49, 0x54, 0x4E,
                    0x54, 0x53, 0x52, 0x53, 0x44, 0x52, 0x52, 0x4E, 0x42, 0x54, 0x59, 0x49, 0x4E, 0x53, 0x49, 0x54,
                    0x4F, 0x4F, 0x59, 0x4E, 0x4E, 0xCA, 0x9D, 0x9D, 0x9D, 0x9D, 0x9D, 0x9D, 0x9D, 0x9E, 0x96, 0x4F,
                    0x53, 0x49, 0x4A, 0x49, 0x40, 0x4E, 0x52, 0x59, 0x42, 0x57, 0x40, 0x52, 0x4F, 0x4E, 0x4E, 0x4F,
                    0x53, 0x4E, 0x4E, 0x4F, 0x49, 0x57, 0x42, 0x4F, 0x4F, 0x4F, 0x54, 0x52, 0x54, 0x59, 0x53, 0x49,
                    0x59, 0x4E, 0x53, 0x4E, 0x57, 0x59, 0x4F, 0x52, 0x4F, 0x42, 0x42, 0x4E, 0x42, 0x57, 0x53, 0x42,
                    0x40, 0x40, 0x53, 0x42, 0x53, 0x98, 0xCA, 0x9D, 0x9D, 0x9D, 0x9D, 0x9D, 0x9D, 0x9D, 0x92, 0x52,
                    0x53, 0x4F, 0x59, 0x4F, 0x49, 0x40, 0x59, 0x54, 0x57, 0x59, 0x57, 0x59, 0x4F, 0x53, 0x54, 0x59,
                    0x57, 0x4F, 0x59, 0x54, 0x59, 0x52, 0x49, 0x4F, 0x52, 0x49, 0x52, 0x49, 0x52, 0x57, 0x4F, 0x59,
                    0x49, 0x52, 0x49, 0x49, 0x40, 0x49, 0x57, 0x4E, 0x4A, 0x49, 0x4E, 0x4E, 0x49, 0x52, 0x40, 0x53,
                    0x42, 0x40, 0x53, 0x42, 0x4F, 0x96, 0xCA, 0x9E, 0x9E, 0x9E, 0x9E, 0x9E, 0x9E, 0x9E, 0xB4, 0x42,
                    0x4F, 0x4E, 0x4E, 0x4F, 0x49, 0x49, 0x4E, 0x49, 0x4E, 0x57, 0x42, 0x42, 0x4F, 0x4E, 0x49, 0x54,
                    0x4E, 0x49, 0x4E, 0x49, 0x42, 0x54, 0x4E, 0x49, 0x40, 0x49, 0x53, 0x53, 0x53, 0x54, 0x59, 0x4F,
                    0x42, 0x4F, 0x52, 0x52, 0x4E, 0x4F, 0x4A, 0x4E, 0x49, 0x49, 0x59, 0x52, 0x4A, 0x4E, 0x42, 0x54,
                    0x54, 0x57, 0x53, 0x4F, 0x42, 0x96, 0xCA, 0x9E, 0x9E, 0x9E, 0x9E, 0x9E, 0x9E, 0x9E, 0x96, 0x52,
                    0x40, 0x49, 0x49, 0x49, 0x4A, 0x49, 0x4F, 0x53, 0x4F, 0x49, 0x4F, 0x49, 0x49, 0x52, 0x52, 0x4E,
                    0x4F, 0x4E, 0x49, 0x49, 0x52, 0x42, 0x54, 0x59, 0x49, 0x4E, 0x52, 0x4E, 0x4E, 0x53, 0x59, 0x53,
                    0x53, 0x49, 0x4A, 0x52, 0x42, 0x42, 0x49, 0x53, 0x53, 0x42, 0x4F, 0x52, 0x49, 0x49, 0x4A, 0x4F,
                    0x53, 0x59, 0x54, 0x54, 0x4E, 0x85, 0xCA, 0x9E, 0x9E, 0x9E, 0x9E, 0x9E, 0x9E, 0x9E, 0xD3, 0x40,
                };

                // Allocate new tile buffer with space for additional tile
                const int32_t tile_size{ResourceManager_DisableEnhancedGraphics ? (GFX_MAP_TILE_SIZE / 2)
                                                                                : GFX_MAP_TILE_SIZE};
                const uint32_t old_buffer_size = m_tile_count * tile_size * tile_size;
                const uint32_t new_buffer_size = (m_tile_count + 1) * tile_size * tile_size;

                auto new_tile_buffer = std::make_unique<uint8_t[]>(new_buffer_size);

                if (!new_tile_buffer) {
                    SDL_Log("World: Failed to allocate memory for SNOW_5 bug fix");
                    return;
                }

                // Copy existing tiles
                memcpy(new_tile_buffer.get(), m_tile_buffer.get(), old_buffer_size);

                // Append tile 411 data (with downsampling if needed)
                if (tile_size == 32) {
                    // Downsample from 64x64 to 32x32 (stride 2 in both X and Y)
                    uint8_t* destination_address = &new_tile_buffer[old_buffer_size];
                    for (int32_t i = 0; i < tile_size; ++i) {
                        for (int32_t j = 0; j < tile_size; ++j) {
                            destination_address[i * tile_size + j] = tile_data[(i * GFX_MAP_TILE_SIZE + j) * 2];
                        }
                    }
                } else {
                    // Copy 64x64 tile directly
                    memcpy(&new_tile_buffer[old_buffer_size], tile_data, tile_size * tile_size);
                }

                // Replace tile buffer
                m_tile_buffer = std::move(new_tile_buffer);

                // Update tile count
                ++m_tile_count;

                // Update tile index at grid position
                m_tile_ids[m_map_size.x * grid_y_66 + grid_x_55] = tile_411;

                // Update surface map
                m_surface_map[m_map_size.x * grid_y_66 + grid_x_55] = SURFACE_TYPE_AIR;

                SDL_Log("World: Applied SNOW_5 bug fix (injected missing tile 411 art)");
            }
        } break;
    }
}

void World::CalculateMinimapScaling() {
    const WindowInfo* mmw = WindowManager_GetWindow(WINDOW_MINIMAP);
    const int32_t mmw_width{mmw->window.lrx - mmw->window.ulx + 1};
    const int32_t mmw_height{mmw->window.lry - mmw->window.uly + 1};

    SDL_assert(mmw_width == mmw_height);

    Point offset(0, 0);
    Point map_size(m_map_size.x, m_map_size.y);
    double scale{1.0};

    if (m_map_size.x != mmw_width || m_map_size.y != mmw_height) {
        if (m_map_size.x > m_map_size.y) {
            if (m_map_size.x == mmw_width) {
                map_size.x = mmw_width;
                map_size.y = m_map_size.y;
                offset.y = (mmw_height - map_size.y) / 2;

            } else {
                scale = static_cast<double>(mmw_width) / m_map_size.x;

                map_size.x = mmw_width;
                map_size.y = m_map_size.y * scale;
                offset.y = (mmw_height - map_size.y) / 2;
            }

        } else if (m_map_size.x == m_map_size.y) {
            map_size.x = mmw_width;
            map_size.y = mmw_height;
            scale = static_cast<double>(mmw_width) / m_map_size.x;

        } else {
            if (m_map_size.y == mmw_height) {
                map_size.x = m_map_size.x;
                map_size.y = mmw_height;
                offset.x = (mmw_width - map_size.x) / 2;

            } else {
                scale = static_cast<double>(mmw_height) / m_map_size.y;

                map_size.x = m_map_size.x * scale;
                map_size.y = mmw_height;
                offset.x = (mmw_width - map_size.x) / 2;
            }
        }
    }

    m_minimap_window_size = map_size;
    m_minimap_window_offset = offset;
    m_minimap_window_scale = scale;
}

std::string World::ComputeHash() const {
    constexpr size_t BLOCK_SIZE{4096};

    FILE* fp = fopen(m_file_path.string().c_str(), "rb");

    if (!fp) {
        return "";
    }

    char hex_digest[SHA256_DIGEST_SIZE * 2 + sizeof('\0')];
    uint8_t data[BLOCK_SIZE];
    uint8_t digest[SHA256_DIGEST_SIZE];
    sha256_ctx ctx;
    size_t data_read;

    sha256_init(&ctx);

    while ((data_read = fread(data, sizeof(uint8_t), sizeof(data), fp)) != 0) {
        sha256_update(&ctx, data, data_read);
    }

    sha256_final(&ctx, digest);

    for (size_t i = 0; i < sizeof(digest); ++i) {
        sprintf(hex_digest + (i * 2), "%02x", digest[i]);
    }

    hex_digest[sizeof(hex_digest) - 1] = '\0';

    fclose(fp);

    return hex_digest;
}

void World::GetRedTintParameters(uint8_t& r_level, uint8_t& g_level, uint8_t& b_level, uint8_t& factor) const {
    r_level = 63;
    g_level = 0;
    b_level = 0;

    if (m_resource_id >= SNOW_1 && m_resource_id <= SNOW_6) {
        factor = 63;
    } else {
        factor = 31;
    }
}

void World::GetWorldTintParameters(uint8_t& r_level, uint8_t& g_level, uint8_t& b_level) const {
    r_level = 63;

    if (m_resource_id >= SNOW_1 && m_resource_id <= SNOW_6) {
        g_level = 0;
        b_level = 0;
    } else {
        g_level = 63;
        b_level = 63;
    }
}

uint8_t World::GetSurfaceType(int32_t grid_x, int32_t grid_y) const {
    if (!m_surface_map) {
        return SURFACE_TYPE_NONE;
    }

    if (grid_x < 0 || grid_x >= m_map_size.x || grid_y < 0 || grid_y >= m_map_size.y) {
        return SURFACE_TYPE_NONE;
    }

    return m_surface_map[grid_y * m_map_size.x + grid_x];
}

uint8_t World::GetGridOverlayColor(uint8_t surface_type) const {
    uint8_t result;

    switch (surface_type) {
        case SURFACE_TYPE_LAND: {
            result = m_grid_overlay_color_land;
        } break;

        case SURFACE_TYPE_WATER: {
            result = m_grid_overlay_color_water;
        } break;

        case SURFACE_TYPE_COAST: {
            result = m_grid_overlay_color_coast;
        } break;

        case SURFACE_TYPE_AIR: {
            result = m_grid_overlay_color_air;
        } break;

        default: {
            result = m_grid_overlay_color_land;
        } break;
    }

    return result;
}
